<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Kindle Chess AI (with Check, Mate & Promotion)</title>
<style>
  body { background:#fff; color:#000; font-family:monospace; text-align:center; }
  table { border-collapse:collapse; margin:10px auto; }
  td {
    width:40px; height:40px;
    text-align:center; vertical-align:middle;
    border:1px solid #000; font-size:24px;
  }
  .dark { background:#ccc; }
  .light { background:#fff; }
  #status { margin-top:10px; }
  button { margin:5px; }
</style>
</head>
<body>
<h2>Kindle Chess AI</h2>
<table id="board"></table>
<div id="status">White to move</div>
<button onclick="resetBoard()">Restart</button>

<script>
const PIECES = {
  'r':'♜','n':'♞','b':'♝','q':'♛','k':'♚','p':'♟',
  'R':'♖','N':'♘','B':'♗','Q':'♕','K':'♔','P':'♙',' ':' '
};

let board = [
  ['r','n','b','q','k','b','n','r'],
  ['p','p','p','p','p','p','p','p'],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  ['P','P','P','P','P','P','P','P'],
  ['R','N','B','Q','K','B','N','R']
];

let selected = null;
let whiteToMove = true;
let gameOver = false;

function drawBoard() {
  const tbl = document.getElementById("board");
  tbl.innerHTML = "";
  for (let r = 0; r < 8; r++) {
    const row = document.createElement("tr");
    for (let c = 0; c < 8; c++) {
      const cell = document.createElement("td");
      cell.innerHTML = PIECES[board[r][c]];
      cell.className = ((r+c)%2==0) ? "light" : "dark";
      if (selected && selected[0]==r && selected[1]==c)
        cell.style.border = "2px solid red";
      cell.onclick = () => selectSquare(r, c);
      row.appendChild(cell);
    }
    tbl.appendChild(row);
  }
}

function selectSquare(r, c) {
  if (gameOver || !whiteToMove) return;
  if (!selected) {
    const p = board[r][c];
    if (p === ' ' || p === p.toLowerCase()) return;
    selected = [r, c];
  } else {
    const [sr, sc] = selected;
    const moves = legalMoves(sr, sc, board);
    const dest = moves.find(m => m[0]==r && m[1]==c);
    if (dest) {
      let newBoard = cloneBoard(board);
      makeMoveOnBoard(newBoard, sr, sc, r, c);
      if (!inCheck(newBoard, true)) {
        makeMove(sr, sc, r, c);
        selected = null;
        drawBoard();
        if (!gameOver) setTimeout(aiMove, 400);
      } else {
        alert("You cannot move into check!");
        selected = null;
      }
    } else {
      selected = null;
    }
  }
  drawBoard();
}

function makeMove(sr, sc, r, c) {
  makeMoveOnBoard(board, sr, sc, r, c);
  handlePromotion(board);
  whiteToMove = !whiteToMove;
  const side = whiteToMove ? "White" : "Black";
  document.getElementById("status").textContent = side + " to move";
  checkGameEnd();
}

function makeMoveOnBoard(b, sr, sc, r, c) {
  b[r][c] = b[sr][sc];
  b[sr][sc] = ' ';
}

function aiMove() {
  if (gameOver) return;
  let moves = [];
  for (let r=0; r<8; r++)
    for (let c=0; c<8; c++) {
      const p = board[r][c];
      if (p === ' ' || p === p.toUpperCase()) continue;
      for (const m of legalMoves(r,c,board)) {
        let b2 = cloneBoard(board);
        makeMoveOnBoard(b2, r, c, m[0], m[1]);
        if (!inCheck(b2, false))
          moves.push({from:[r,c], to:m});
      }
    }
  if (moves.length === 0) {
    document.getElementById("status").textContent = "White wins (checkmate)!";
    gameOver = true;
    return;
  }
  const value = {'p':1,'n':3,'b':3,'r':5,'q':9,'k':100,' ':0};
  moves.sort((a,b)=>{
    const ta = board[a.to[0]][a.to[1]];
    const tb = board[b.to[0]][b.to[1]];
    return value[tb.toLowerCase()] - value[ta.toLowerCase()];
  });
  const best = moves[0];
  makeMove(best.from[0], best.from[1], best.to[0], best.to[1]);
  handlePromotion(board);
  drawBoard();
}

function handlePromotion(b) {
  for (let c=0;c<8;c++) {
    if (b[0][c]==='P') b[0][c]='Q';
    if (b[7][c]==='p') b[7][c]='q';
  }
}

function checkGameEnd() {
  const check = inCheck(board, whiteToMove);
  const hasMove = hasLegalMove(whiteToMove);
  if (check && !hasMove) {
    document.getElementById("status").textContent =
      (whiteToMove ? "White" : "Black") + " is checkmated!";
    gameOver = true;
  } else if (!check && !hasMove) {
    document.getElementById("status").textContent = "Stalemate!";
    gameOver = true;
  } else if (check) {
    document.getElementById("status").textContent += " — CHECK!";
  }
}

function inCheck(b, whiteSide) {
  const king = whiteSide ? 'K' : 'k';
  let kr=-1,kc=-1;
  for(let r=0;r<8;r++)for(let c=0;c<8;c++)
    if(b[r][c]===king){kr=r;kc=c;}
  if(kr==-1) return false;
  for(let r=0;r<8;r++)
    for(let c=0;c<8;c++){
      const p=b[r][c];
      if(p===' ' || (whiteSide && p===p.toUpperCase()) || (!whiteSide && p===p.toLowerCase())) continue;
      const moves=legalMoves(r,c,b);
      if(moves.some(m=>m[0]==kr&&m[1]==kc)) return true;
    }
  return false;
}

function hasLegalMove(whiteSide){
  for(let r=0;r<8;r++)
    for(let c=0;c<8;c++){
      const p=board[r][c];
      if(p===' ' || (whiteSide && p===p.toLowerCase()) || (!whiteSide && p===p.toUpperCase())) continue;
      const moves=legalMoves(r,c,board);
      for(const m of moves){
        let b2=cloneBoard(board);
        makeMoveOnBoard(b2,r,c,m[0],m[1]);
        handlePromotion(b2);
        if(!inCheck(b2,whiteSide))return true;
      }
    }
  return false;
}

// Move generation
function inBounds(r,c){return r>=0 && r<8 && c>=0 && c<8;}
function isEnemy(a,b){if(b===' ')return false; return (a===a.toUpperCase())!=(b===b.toUpperCase());}
function isFriend(a,b){if(b===' ')return false; return (a===a.toUpperCase())==(b===b.toUpperCase());}

function legalMoves(r,c,b){
  const p=b[r][c];
  const moves=[];
  const dir=(p==='P')?-1:(p==='p')?1:0;
  if(p==='P'||p==='p'){ // pawns
    const step=r+dir;
    if(inBounds(step,c)&&b[step][c]===' ')moves.push([step,c]);
    for(const dc of [-1,1]){
      const rr=r+dir,cc=c+dc;
      if(inBounds(rr,cc)&&b[rr][cc]!==' '&&isEnemy(p,b[rr][cc]))moves.push([rr,cc]);
    }
  }else if(p.toLowerCase()==='n'){
    const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const [dr,dc]of deltas){
      const rr=r+dr,cc=c+dc;
      if(inBounds(rr,cc)&&!isFriend(p,b[rr][cc]))moves.push([rr,cc]);
    }
  }else if(p.toLowerCase()==='b'){slides(r,c,moves,[[1,1],[1,-1],[-1,1],[-1,-1]],p,b);}
  else if(p.toLowerCase()==='r'){slides(r,c,moves,[[1,0],[-1,0],[0,1],[0,-1]],p,b);}
  else if(p.toLowerCase()==='q'){slides(r,c,moves,[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],p,b);}
  else if(p.toLowerCase()==='k'){
    for(let dr=-1;dr<=1;dr++)
      for(let dc=-1;dc<=1;dc++)
        if(dr||dc){
          const rr=r+dr,cc=c+dc;
          if(inBounds(rr,cc)&&!isFriend(p,b[rr][cc]))moves.push([rr,cc]);
        }
  }
  return moves;
}

function slides(r,c,moves,dirs,p,b){
  for(const [dr,dc]of dirs){
    let rr=r+dr,cc=c+dc;
    while(inBounds(rr,cc)){
      if(b[rr][cc]===' '){
        moves.push([rr,cc]);
      }else{
        if(isEnemy(p,b[rr][cc]))moves.push([rr,cc]);
        break;
      }
      rr+=dr;cc+=dc;
    }
  }
}

function cloneBoard(b){return b.map(r=>r.slice());}
function resetBoard(){location.reload();}

drawBoard();
</script>
</body>
</html>